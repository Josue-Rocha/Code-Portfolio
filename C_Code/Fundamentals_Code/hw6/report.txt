// report.txt

1.
From a user's perspective, they can either do bash or interactive mode. For BASH mode they enter the name of the file with the desired points at the command line and the programwill read that file and run. If the users enteres more than one thing at the command line then they will get an error message. The program will automatically run the game of life in an infinite loop which the user can end by typing ^C. For interactive mode, the user just has to run the executable which will then ask them for a commanda dn print an empty board. The user can add a point by typing "a" followed by two numbers under 40 seperated by a space. They can also remove a point by typing "r" instead of "a". If the user just types "N" the program will apply the rules of the game of life once. If the user types "p" then the program wil enter an infite loop where it applies the rules of the game constantly. Assuming the user never types "p", they can exit the program by typing "q".
2. 
Internally, the program is split in 3. The header, main, and functions file. lifefunc.h is the header file and it just declares the functions. The main file is called playlife.c and it is effectivly split in 2 havles. The first half is for interactive mode with has a series if if an else if statementes under a while loop according to what the user wants to do. The while loop is set to while(1) so it will go on forever unless the user enters "q" which will break the loop and effectivley end the program. The user's choice is taken in by an fgets function and placed into the choice_str string. The program first reads the first index of that string to read the first letter and then goes through the if and else if statements that the letter corresponds to. If no such letter exists, then it will print an error message. If the first letter is "a" or "r" the program uses sscanf to pick up the two integers in the choice_str string and either add or remove the desired point depending on what the first letter was. If the first letter is "n" then it applies the rules of the game of life once, and if the letter is "p" then it goes into an infinite while loop. To make it more user friendly, there are the system clear and usleep functions which are there to clear the screen after each pass and pause the program so the user can see the progression. The second half of the main file is for bash mode and it effectivley works the same way as option "p" in interactive mode. Only it takes in a string from the command line and looks for a file of the same name. If it finds it, it reads from the file and plots the appropiate points. The final bit of the program is the lifefunc.c file which is where all the functions are defined. There is the display function while displays the array and it's borderes. There is also the check_scene function which takes in the array and one specific point. It then checks the neighbors of that point as well as whether that point is alive or dead. If it is dead and has three neighbors it returns 0; if it is alive and does not have 2 or 3 neighbors it returns 1, these go according to the rules of the game of life with which we are working. This function is only used in the apply_rules function which calls the check_scene for function for each point in the array. If the check scene returns 0, then it means that the point is dead and has exactly 3 neighbors and so it makes the point alive by changing it to 'X'. If the check_scene function returns 1; then that means that the point is alive but does not have exactly 2 or 3 neighbors so it 'kills' it by making it and empty space. The final function is just to make two arrays equal to each other. This is helpful when working with a temporary board in the main file. The when applying the rules of the game, the main file will use this function to set the temp_arr character array equal to arr which is our board. It then applies the rules of the game to the temp_arr but reads from arr so as to apply them correctly. 
3.
To ensure that the program runs correctly and works as it should, I ran it several times on my end. I checked each of the scenes and the glifer.txt file to see how the program would respond. I even intentionally made several errors from the user's perspective to ensure that I got an error message.
